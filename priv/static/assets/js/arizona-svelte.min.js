/*! Arizona Svelte v0.2.0 | Apache-2.0 License */
class he {
  /**
   * Create a new component registry
   */
  constructor() {
    this.components = /* @__PURE__ */ new Map();
  }
  /**
   * Register a component with the given name
   * @param {string} name - Component name
   * @param {Function} component - Svelte component class
   */
  registerComponent(t, n) {
    if (typeof t != "string" || !t.trim())
      throw new Error("Component name must be a non-empty string");
    if (typeof n != "function")
      throw new Error("Component must be a Svelte component class");
    this.components.set(t, n);
  }
  /**
   * Get a component by name
   * @param {string} name - Component name
   * @returns {Function|null} Svelte component class or null if not found
   */
  getComponent(t) {
    return this.components.get(t) || null;
  }
  /**
   * Check if a component is registered
   * @param {string} name - Component name
   * @returns {boolean}
   */
  hasComponent(t) {
    return this.components.has(t);
  }
  /**
   * Get all registered component names
   * @returns {string[]}
   */
  getComponentNames() {
    return Array.from(this.components.keys());
  }
  /**
   * Unregister a component
   * @param {string} name - Component name
   * @returns {boolean} True if component was removed, false if it didn't exist
   */
  unregisterComponent(t) {
    return this.components.delete(t);
  }
  /**
   * Register multiple components at once
   * @param {Object.<string, Function>} components - Object mapping component names to component classes
   * @returns {number} Number of components registered
   * @example
   * registry.registerComponents({
   *   Counter: CounterComponent,
   *   HelloWorld: HelloWorldComponent,
   *   Dashboard: DashboardComponent
   * });
   */
  registerComponents(t) {
    if (!t || typeof t != "object")
      throw new Error("Components must be an object mapping names to component classes");
    let n = 0;
    for (const [r, s] of Object.entries(t))
      this.registerComponent(r, s), n++;
    return n;
  }
  /**
   * Clear all registered components
   */
  clear() {
    this.components.clear();
  }
}
const qt = !1;
var jt = Array.isArray, de = Array.prototype.indexOf, ve = Array.from, wt = Object.defineProperty, tt = Object.getOwnPropertyDescriptor, pe = Object.prototype, _e = Array.prototype, me = Object.getPrototypeOf, Ot = Object.isExtensible;
function ge(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function ye() {
  var e, t, n = new Promise((r, s) => {
    e = r, t = s;
  });
  return { promise: n, resolve: e, reject: t };
}
const T = 2, $t = 4, be = 8, Q = 16, Y = 32, B = 64, Mt = 128, N = 256, ht = 512, y = 1024, k = 2048, U = 4096, Z = 8192, it = 16384, Vt = 32768, Yt = 65536, Rt = 1 << 17, we = 1 << 18, mt = 1 << 19, Ee = 1 << 20, Et = 1 << 21, Bt = 1 << 22, dt = 1 << 23, yt = Symbol("$state"), Ht = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Ce() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Se() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Ae() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Me() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Te() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
const g = Symbol();
function xe() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
function ke(e) {
  return e === this.v;
}
let Ne = !1, L = null;
function vt(e) {
  L = e;
}
function Oe(e, t = !1, n) {
  L = {
    p: L,
    c: null,
    e: null,
    s: e,
    x: null,
    l: null
  };
}
function Re(e) {
  var t = (
    /** @type {ComponentContext} */
    L
  ), n = t.e;
  if (n !== null) {
    t.e = null;
    for (var r of n)
      Ke(r);
  }
  return L = t.p, /** @type {T} */
  {};
}
function Kt() {
  return !0;
}
let K = [];
function Le() {
  var e = K;
  K = [], ge(e);
}
function Tt(e) {
  if (K.length === 0) {
    var t = K;
    queueMicrotask(() => {
      t === K && Le();
    });
  }
  K.push(e);
}
const ze = /* @__PURE__ */ new WeakMap();
function Wt(e) {
  var t = _;
  if (t === null)
    return p.f |= dt, e;
  if ((t.f & Vt) === 0) {
    if ((t.f & Mt) === 0)
      throw !t.parent && e instanceof Error && Gt(e), e;
    t.b.error(e);
  } else
    pt(e, t);
}
function pt(e, t) {
  for (; t !== null; ) {
    if ((t.f & Mt) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e instanceof Error && Gt(e), e;
}
function Gt(e) {
  const t = ze.get(e);
  t && (wt(e, "message", {
    value: t.message
  }), wt(e, "stack", {
    value: t.stack
  }));
}
const bt = /* @__PURE__ */ new Set();
let w = null, Ct = /* @__PURE__ */ new Set(), nt = [], xt = null, St = !1;
class O {
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  #i = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #h = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #o = null;
  /**
   * True if an async effect inside this batch resolved and
   * its parent branch was already deleted
   */
  #f = !1;
  /**
   * Async effects (created inside `async_derived`) encountered during processing.
   * These run after the rest of the batch has updated, since they should
   * always have the latest values
   * @type {Effect[]}
   */
  #s = [];
  /**
   * The same as `#async_effects`, but for effects inside a newly-created
   * `<svelte:boundary>` — these do not prevent the batch from committing
   * @type {Effect[]}
   */
  #n = [];
  /**
   * Template effects and `$effect.pre` effects, which run when
   * a batch is committed
   * @type {Effect[]}
   */
  #t = [];
  /**
   * The same as `#render_effects`, but for `$effect` (which runs after)
   * @type {Effect[]}
   */
  #r = [];
  /**
   * Block effects, which may need to re-run on subsequent flushes
   * in order to update internal sources (e.g. each block items)
   * @type {Effect[]}
   */
  #l = [];
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #c = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #a = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed — we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    nt = [];
    for (const s of t)
      this.#d(s);
    if (this.#s.length === 0 && this.#h === 0) {
      this.#v();
      var n = this.#t, r = this.#r;
      this.#t = [], this.#r = [], this.#l = [], w = null, Lt(n), Lt(r), w === null ? w = this : bt.delete(this), this.#o?.resolve();
    } else
      this.#u(this.#t), this.#u(this.#r), this.#u(this.#l);
    for (const s of this.#s)
      J(s);
    for (const s of this.#n)
      J(s);
    this.#s = [], this.#n = [];
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   */
  #d(t) {
    t.f ^= y;
    for (var n = t.first; n !== null; ) {
      var r = n.f, s = (r & (Y | B)) !== 0, i = s && (r & y) !== 0, l = i || (r & Z) !== 0 || this.skipped_effects.has(n);
      if (!l && n.fn !== null) {
        if (s)
          n.f ^= y;
        else if ((r & $t) !== 0)
          this.#r.push(n);
        else if ((r & y) === 0)
          if ((r & Bt) !== 0) {
            var a = n.b?.is_pending() ? this.#n : this.#s;
            a.push(n);
          } else gt(n) && ((n.f & Q) !== 0 && this.#l.push(n), J(n));
        var o = n.first;
        if (o !== null) {
          n = o;
          continue;
        }
      }
      var u = n.parent;
      for (n = n.next; n === null && u !== null; )
        n = u.next, u = u.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #u(t) {
    for (const n of t)
      ((n.f & k) !== 0 ? this.#c : this.#a).push(n), S(n, y);
    t.length = 0;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.#i.has(t) || this.#i.set(t, n), this.current.set(t, t.v);
  }
  activate() {
    w = this;
  }
  deactivate() {
    w = null;
    for (const t of Ct)
      if (Ct.delete(t), t(), w !== null)
        break;
  }
  neuter() {
    this.#f = !0;
  }
  flush() {
    nt.length > 0 ? Fe() : this.#v(), w === this && (this.#h === 0 && bt.delete(this), this.deactivate());
  }
  /**
   * Append and remove branches to/from the DOM
   */
  #v() {
    if (!this.#f)
      for (const t of this.#e)
        t();
    this.#e.clear();
  }
  increment() {
    this.#h += 1;
  }
  decrement() {
    if (this.#h -= 1, this.#h === 0) {
      for (const t of this.#c)
        S(t, k), rt(t);
      for (const t of this.#a)
        S(t, U), rt(t);
      this.#t = [], this.#r = [], this.flush();
    } else
      this.deactivate();
  }
  /** @param {() => void} fn */
  add_callback(t) {
    this.#e.add(t);
  }
  settled() {
    return (this.#o ??= ye()).promise;
  }
  static ensure() {
    if (w === null) {
      const t = w = new O();
      bt.add(w), O.enqueue(() => {
        w === t && t.flush();
      });
    }
    return w;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    Tt(t);
  }
}
function Fe() {
  var e = G;
  St = !0;
  try {
    var t = 0;
    for (Ft(!0); nt.length > 0; ) {
      var n = O.ensure();
      if (t++ > 1e3) {
        var r, s;
        De();
      }
      n.process(nt), P.clear();
    }
  } finally {
    St = !1, Ft(e), xt = null;
  }
}
function De() {
  try {
    Ce();
  } catch (e) {
    pt(e, xt);
  }
}
let $ = null;
function Lt(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (it | Z)) === 0 && gt(r) && ($ = [], J(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? ie(r) : r.fn = null), $?.length > 0)) {
        P.clear();
        for (const s of $)
          J(s);
        $ = [];
      }
    }
    $ = null;
  }
}
function rt(e) {
  for (var t = xt = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (St && t === _ && (n & Q) !== 0)
      return;
    if ((n & (B | Y)) !== 0) {
      if ((n & y) === 0) return;
      t.f ^= y;
    }
  }
  nt.push(t);
}
function Pe(e) {
  let t = 0, n = Nt(0), r;
  return () => {
    He() && (W(n), Ge(() => (t === 0 && (r = rn(() => e(() => et(n)))), t += 1, () => {
      Tt(() => {
        t -= 1, t === 0 && (r?.(), r = void 0, et(n));
      });
    })));
  };
}
var Ie = Yt | mt | Mt;
function Ue(e, t, n) {
  new qe(e, t, n);
}
class qe {
  /** @type {Boundary | null} */
  parent;
  #i = !1;
  /** @type {TemplateNode} */
  #e;
  /** @type {TemplateNode | null} */
  #h = null;
  /** @type {BoundaryProps} */
  #o;
  /** @type {((anchor: Node) => void)} */
  #f;
  /** @type {Effect} */
  #s;
  /** @type {Effect | null} */
  #n = null;
  /** @type {Effect | null} */
  #t = null;
  /** @type {Effect | null} */
  #r = null;
  /** @type {DocumentFragment | null} */
  #l = null;
  #c = 0;
  #a = 0;
  #d = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #u = null;
  #v = () => {
    this.#u && Qt(this.#u, this.#c);
  };
  #g = Pe(() => (this.#u = Nt(this.#c), () => {
    this.#u = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(t, n, r) {
    this.#e = t, this.#o = n, this.#f = r, this.parent = /** @type {Effect} */
    _.b, this.#i = !!this.#o.pending, this.#s = Je(() => {
      _.b = this;
      {
        try {
          this.#n = q(() => r(this.#e));
        } catch (s) {
          this.error(s);
        }
        this.#a > 0 ? this.#_() : this.#i = !1;
      }
    }, Ie);
  }
  #y() {
    try {
      this.#n = q(() => this.#f(this.#e));
    } catch (t) {
      this.error(t);
    }
    this.#i = !1;
  }
  #b() {
    const t = this.#o.pending;
    t && (this.#t = q(() => t(this.#e)), O.enqueue(() => {
      this.#n = this.#p(() => (O.ensure(), q(() => this.#f(this.#e)))), this.#a > 0 ? this.#_() : (ct(
        /** @type {Effect} */
        this.#t,
        () => {
          this.#t = null;
        }
      ), this.#i = !1);
    }));
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#i || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#o.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #p(t) {
    var n = _, r = p, s = L;
    I(this.#s), C(this.#s), vt(this.#s.ctx);
    try {
      return t();
    } catch (i) {
      return Wt(i), null;
    } finally {
      I(n), C(r), vt(s);
    }
  }
  #_() {
    const t = (
      /** @type {(anchor: Node) => void} */
      this.#o.pending
    );
    this.#n !== null && (this.#l = document.createDocumentFragment(), je(this.#n, this.#l)), this.#t === null && (this.#t = q(() => t(this.#e)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #m(t) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#m(t);
      return;
    }
    this.#a += t, this.#a === 0 && (this.#i = !1, this.#t && ct(this.#t, () => {
      this.#t = null;
    }), this.#l && (this.#e.before(this.#l), this.#l = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(t) {
    this.#m(t), this.#c += t, Ct.add(this.#v);
  }
  get_effect_pending() {
    return this.#g(), W(
      /** @type {Source<number>} */
      this.#u
    );
  }
  /** @param {unknown} error */
  error(t) {
    var n = this.#o.onerror;
    let r = this.#o.failed;
    if (this.#d || !n && !r)
      throw t;
    this.#n && (x(this.#n), this.#n = null), this.#t && (x(this.#t), this.#t = null), this.#r && (x(this.#r), this.#r = null);
    var s = !1, i = !1;
    const l = () => {
      if (s) {
        xe();
        return;
      }
      s = !0, i && Te(), O.ensure(), this.#c = 0, this.#r !== null && ct(this.#r, () => {
        this.#r = null;
      }), this.#i = this.has_pending_snippet(), this.#n = this.#p(() => (this.#d = !1, q(() => this.#f(this.#e)))), this.#a > 0 ? this.#_() : this.#i = !1;
    };
    var a = p;
    try {
      C(null), i = !0, n?.(t, l), i = !1;
    } catch (o) {
      pt(o, this.#s && this.#s.parent);
    } finally {
      C(a);
    }
    r && Tt(() => {
      this.#r = this.#p(() => {
        this.#d = !0;
        try {
          return q(() => {
            r(
              this.#e,
              () => t,
              () => l
            );
          });
        } catch (o) {
          return pt(
            o,
            /** @type {Effect} */
            this.#s.parent
          ), null;
        } finally {
          this.#d = !1;
        }
      });
    });
  }
}
function je(e, t) {
  for (var n = e.nodes_start, r = e.nodes_end; n !== null; ) {
    var s = n === r ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ee(n)
    );
    t.append(n), n = s;
  }
}
function Jt(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      x(
        /** @type {Effect} */
        t[n]
      );
  }
}
function $e(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & T) === 0)
      return (
        /** @type {Effect} */
        t
      );
    t = t.parent;
  }
  return null;
}
function kt(e) {
  var t, n = _;
  I($e(e));
  try {
    Jt(e), t = fe(e);
  } finally {
    I(n);
  }
  return t;
}
function Zt(e) {
  var t = kt(e);
  if (e.equals(t) || (e.v = t, e.wv = ue()), !lt) {
    var n = (D || (e.f & N) !== 0) && e.deps !== null ? U : y;
    S(e, n);
  }
}
const P = /* @__PURE__ */ new Map();
function Nt(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: ke,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function F(e, t) {
  const n = Nt(e);
  return tn(n), n;
}
function j(e, t, n = !1) {
  p !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!M || (p.f & Rt) !== 0) && Kt() && (p.f & (T | Q | Bt | Rt)) !== 0 && !R?.includes(e) && Me();
  let r = n ? X(t) : t;
  return Qt(e, r);
}
function Qt(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    lt ? P.set(e, t) : P.set(e, n), e.v = t;
    var r = O.ensure();
    r.capture(e, n), (e.f & T) !== 0 && ((e.f & k) !== 0 && kt(
      /** @type {Derived} */
      e
    ), S(e, (e.f & N) === 0 ? y : U)), e.wv = ue(), Xt(e, k), _ !== null && (_.f & y) !== 0 && (_.f & (Y | B)) === 0 && (E === null ? en([e]) : E.push(e));
  }
  return t;
}
function et(e) {
  j(e, e.v + 1);
}
function Xt(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, s = 0; s < r; s++) {
      var i = n[s], l = i.f, a = (l & k) === 0;
      a && S(i, t), (l & T) !== 0 ? Xt(
        /** @type {Derived} */
        i,
        U
      ) : a && ((l & Q) !== 0 && $ !== null && $.push(
        /** @type {Effect} */
        i
      ), rt(
        /** @type {Effect} */
        i
      ));
    }
}
function X(e) {
  if (typeof e != "object" || e === null || yt in e)
    return e;
  const t = me(e);
  if (t !== pe && t !== _e)
    return e;
  var n = /* @__PURE__ */ new Map(), r = jt(e), s = /* @__PURE__ */ F(0), i = V, l = (a) => {
    if (V === i)
      return a();
    var o = p, u = V;
    C(null), Pt(i);
    var c = a();
    return C(o), Pt(u), c;
  };
  return r && n.set("length", /* @__PURE__ */ F(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(a, o, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Se();
        var c = n.get(o);
        return c === void 0 ? c = l(() => {
          var d = /* @__PURE__ */ F(u.value);
          return n.set(o, d), d;
        }) : j(c, u.value, !0), !0;
      },
      deleteProperty(a, o) {
        var u = n.get(o);
        if (u === void 0) {
          if (o in a) {
            const c = l(() => /* @__PURE__ */ F(g));
            n.set(o, c), et(s);
          }
        } else
          j(u, g), et(s);
        return !0;
      },
      get(a, o, u) {
        if (o === yt)
          return e;
        var c = n.get(o), d = o in a;
        if (c === void 0 && (!d || tt(a, o)?.writable) && (c = l(() => {
          var f = X(d ? a[o] : g), v = /* @__PURE__ */ F(f);
          return v;
        }), n.set(o, c)), c !== void 0) {
          var h = W(c);
          return h === g ? void 0 : h;
        }
        return Reflect.get(a, o, u);
      },
      getOwnPropertyDescriptor(a, o) {
        var u = Reflect.getOwnPropertyDescriptor(a, o);
        if (u && "value" in u) {
          var c = n.get(o);
          c && (u.value = W(c));
        } else if (u === void 0) {
          var d = n.get(o), h = d?.v;
          if (d !== void 0 && h !== g)
            return {
              enumerable: !0,
              configurable: !0,
              value: h,
              writable: !0
            };
        }
        return u;
      },
      has(a, o) {
        if (o === yt)
          return !0;
        var u = n.get(o), c = u !== void 0 && u.v !== g || Reflect.has(a, o);
        if (u !== void 0 || _ !== null && (!c || tt(a, o)?.writable)) {
          u === void 0 && (u = l(() => {
            var h = c ? X(a[o]) : g, f = /* @__PURE__ */ F(h);
            return f;
          }), n.set(o, u));
          var d = W(u);
          if (d === g)
            return !1;
        }
        return c;
      },
      set(a, o, u, c) {
        var d = n.get(o), h = o in a;
        if (r && o === "length")
          for (var f = u; f < /** @type {Source<number>} */
          d.v; f += 1) {
            var v = n.get(f + "");
            v !== void 0 ? j(v, g) : f in a && (v = l(() => /* @__PURE__ */ F(g)), n.set(f + "", v));
          }
        if (d === void 0)
          (!h || tt(a, o)?.writable) && (d = l(() => /* @__PURE__ */ F(void 0)), j(d, X(u)), n.set(o, d));
        else {
          h = d.v !== g;
          var A = l(() => X(u));
          j(d, A);
        }
        var ut = Reflect.getOwnPropertyDescriptor(a, o);
        if (ut?.set && ut.set.call(c, u), !h) {
          if (r && typeof o == "string") {
            var at = (
              /** @type {Source<number>} */
              n.get("length")
            ), z = Number(o);
            Number.isInteger(z) && z >= at.v && j(at, z + 1);
          }
          et(s);
        }
        return !0;
      },
      ownKeys(a) {
        W(s);
        var o = Reflect.ownKeys(a).filter((d) => {
          var h = n.get(d);
          return h === void 0 || h.v !== g;
        });
        for (var [u, c] of n)
          c.v !== g && !(u in a) && o.push(u);
        return o;
      },
      setPrototypeOf() {
        Ae();
      }
    }
  );
}
var zt, te;
function Ve() {
  if (zt === void 0) {
    zt = window;
    var e = Element.prototype, t = Node.prototype, n = Text.prototype;
    tt(t, "firstChild").get, te = tt(t, "nextSibling").get, Ot(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), Ot(n) && (n.__t = void 0);
  }
}
function Ye(e = "") {
  return document.createTextNode(e);
}
// @__NO_SIDE_EFFECTS__
function ee(e) {
  return te.call(e);
}
function ne(e) {
  var t = p, n = _;
  C(null), I(null);
  try {
    return e();
  } finally {
    C(t), I(n);
  }
}
function Be(e, t) {
  var n = t.last;
  n === null ? t.last = t.first = e : (n.next = e, e.prev = n, t.last = e);
}
function ot(e, t, n, r = !0) {
  var s = _;
  s !== null && (s.f & Z) !== 0 && (e |= Z);
  var i = {
    ctx: L,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: e | k,
    first: null,
    fn: t,
    last: null,
    next: null,
    parent: s,
    b: s && s.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (n)
    try {
      J(i), i.f |= Vt;
    } catch (o) {
      throw x(i), o;
    }
  else t !== null && rt(i);
  if (r) {
    var l = i;
    if (n && l.deps === null && l.teardown === null && l.nodes_start === null && l.first === l.last && // either `null`, or a singular child
    (l.f & mt) === 0 && (l = l.first), l !== null && (l.parent = s, s !== null && Be(l, s), p !== null && (p.f & T) !== 0 && (e & B) === 0)) {
      var a = (
        /** @type {Derived} */
        p
      );
      (a.effects ??= []).push(l);
    }
  }
  return i;
}
function He() {
  return p !== null && !M;
}
function Ke(e) {
  return ot($t | Ee, e, !1);
}
function We(e) {
  O.ensure();
  const t = ot(B | mt, e, !0);
  return (n = {}) => new Promise((r) => {
    n.outro ? ct(t, () => {
      x(t), r(void 0);
    }) : (x(t), r(void 0));
  });
}
function Ge(e, t = 0) {
  return ot(be | t, e, !0);
}
function Je(e, t = 0) {
  var n = ot(Q | t, e, !0);
  return n;
}
function q(e, t = !0) {
  return ot(Y | mt, e, !0, t);
}
function re(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = lt, r = p;
    Dt(!0), C(null);
    try {
      t.call(null);
    } finally {
      Dt(n), C(r);
    }
  }
}
function se(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const s = n.ac;
    s !== null && ne(() => {
      s.abort(Ht);
    });
    var r = n.next;
    (n.f & B) !== 0 ? n.parent = null : x(n, t), n = r;
  }
}
function Ze(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Y) === 0 && x(t), t = n;
  }
}
function x(e, t = !0) {
  var n = !1;
  (t || (e.f & we) !== 0) && e.nodes_start !== null && e.nodes_end !== null && (Qe(
    e.nodes_start,
    /** @type {TemplateNode} */
    e.nodes_end
  ), n = !0), se(e, t && !n), _t(e, 0), S(e, it);
  var r = e.transitions;
  if (r !== null)
    for (const i of r)
      i.stop();
  re(e);
  var s = e.parent;
  s !== null && s.first !== null && ie(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = e.ac = null;
}
function Qe(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ee(e)
    );
    e.remove(), e = n;
  }
}
function ie(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
function ct(e, t) {
  var n = [];
  oe(e, n, !0), Xe(n, () => {
    x(e), t && t();
  });
}
function Xe(e, t) {
  var n = e.length;
  if (n > 0) {
    var r = () => --n || t();
    for (var s of e)
      s.out(r);
  } else
    t();
}
function oe(e, t, n) {
  if ((e.f & Z) === 0) {
    if (e.f ^= Z, e.transitions !== null)
      for (const l of e.transitions)
        (l.is_global || n) && t.push(l);
    for (var r = e.first; r !== null; ) {
      var s = r.next, i = (r.f & Yt) !== 0 || (r.f & Y) !== 0;
      oe(r, t, i ? n : !1), r = s;
    }
  }
}
let G = !1;
function Ft(e) {
  G = e;
}
let lt = !1;
function Dt(e) {
  lt = e;
}
let p = null, M = !1;
function C(e) {
  p = e;
}
let _ = null;
function I(e) {
  _ = e;
}
let R = null;
function tn(e) {
  p !== null && (R === null ? R = [e] : R.push(e));
}
let m = null, b = 0, E = null;
function en(e) {
  E = e;
}
let le = 1, st = 0, V = st;
function Pt(e) {
  V = e;
}
let D = !1;
function ue() {
  return ++le;
}
function gt(e) {
  var t = e.f;
  if ((t & k) !== 0)
    return !0;
  if ((t & U) !== 0) {
    var n = e.deps, r = (t & N) !== 0;
    if (n !== null) {
      var s, i, l = (t & ht) !== 0, a = r && _ !== null && !D, o = n.length;
      if ((l || a) && (_ === null || (_.f & it) === 0)) {
        var u = (
          /** @type {Derived} */
          e
        ), c = u.parent;
        for (s = 0; s < o; s++)
          i = n[s], (l || !i?.reactions?.includes(u)) && (i.reactions ??= []).push(u);
        l && (u.f ^= ht), a && c !== null && (c.f & N) === 0 && (u.f ^= N);
      }
      for (s = 0; s < o; s++)
        if (i = n[s], gt(
          /** @type {Derived} */
          i
        ) && Zt(
          /** @type {Derived} */
          i
        ), i.wv > e.wv)
          return !0;
    }
    (!r || _ !== null && !D) && S(e, y);
  }
  return !1;
}
function ae(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !R?.includes(e))
    for (var s = 0; s < r.length; s++) {
      var i = r[s];
      (i.f & T) !== 0 ? ae(
        /** @type {Derived} */
        i,
        t,
        !1
      ) : t === i && (n ? S(i, k) : (i.f & y) !== 0 && S(i, U), rt(
        /** @type {Effect} */
        i
      ));
    }
}
function fe(e) {
  var t = m, n = b, r = E, s = p, i = D, l = R, a = L, o = M, u = V, c = e.f;
  m = /** @type {null | Value[]} */
  null, b = 0, E = null, D = (c & N) !== 0 && (M || !G || p === null), p = (c & (Y | B)) === 0 ? e : null, R = null, vt(e.ctx), M = !1, V = ++st, e.ac !== null && (ne(() => {
    e.ac.abort(Ht);
  }), e.ac = null);
  try {
    e.f |= Et;
    var d = (
      /** @type {Function} */
      e.fn
    ), h = d(), f = e.deps;
    if (m !== null) {
      var v;
      if (_t(e, b), f !== null && b > 0)
        for (f.length = b + m.length, v = 0; v < m.length; v++)
          f[b + v] = m[v];
      else
        e.deps = f = m;
      if (!D || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (c & T) !== 0 && /** @type {import('#client').Derived} */
      e.reactions !== null)
        for (v = b; v < f.length; v++)
          (f[v].reactions ??= []).push(e);
    } else f !== null && b < f.length && (_t(e, b), f.length = b);
    if (Kt() && E !== null && !M && f !== null && (e.f & (T | U | k)) === 0)
      for (v = 0; v < /** @type {Source[]} */
      E.length; v++)
        ae(
          E[v],
          /** @type {Effect} */
          e
        );
    return s !== null && s !== e && (st++, E !== null && (r === null ? r = E : r.push(.../** @type {Source[]} */
    E))), (e.f & dt) !== 0 && (e.f ^= dt), h;
  } catch (A) {
    return Wt(A);
  } finally {
    e.f ^= Et, m = t, b = n, E = r, p = s, D = i, R = l, vt(a), M = o, V = u;
  }
}
function nn(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = de.call(n, e);
    if (r !== -1) {
      var s = n.length - 1;
      s === 0 ? n = t.reactions = null : (n[r] = n[s], n.pop());
    }
  }
  n === null && (t.f & T) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (m === null || !m.includes(t)) && (S(t, U), (t.f & (N | ht)) === 0 && (t.f ^= ht), Jt(
    /** @type {Derived} **/
    t
  ), _t(
    /** @type {Derived} **/
    t,
    0
  ));
}
function _t(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      nn(e, n[r]);
}
function J(e) {
  var t = e.f;
  if ((t & it) === 0) {
    S(e, y);
    var n = _, r = G;
    _ = e, G = !0;
    try {
      (t & Q) !== 0 ? Ze(e) : se(e), re(e);
      var s = fe(e);
      e.teardown = typeof s == "function" ? s : null, e.wv = le;
      var i;
      qt && Ne && (e.f & k) !== 0 && e.deps;
    } finally {
      G = r, _ = n;
    }
  }
}
function W(e) {
  var t = e.f, n = (t & T) !== 0;
  if (p !== null && !M) {
    var r = _ !== null && (_.f & it) !== 0;
    if (!r && !R?.includes(e)) {
      var s = p.deps;
      if ((p.f & Et) !== 0)
        e.rv < st && (e.rv = st, m === null && s !== null && s[b] === e ? b++ : m === null ? m = [e] : (!D || !m.includes(e)) && m.push(e));
      else {
        (p.deps ??= []).push(e);
        var i = e.reactions;
        i === null ? e.reactions = [p] : i.includes(p) || i.push(p);
      }
    }
  } else if (n && /** @type {Derived} */
  e.deps === null && /** @type {Derived} */
  e.effects === null) {
    var l = (
      /** @type {Derived} */
      e
    ), a = l.parent;
    a !== null && (a.f & N) === 0 && (l.f ^= N);
  }
  if (lt) {
    if (P.has(e))
      return P.get(e);
    if (n) {
      l = /** @type {Derived} */
      e;
      var o = l.v;
      return ((l.f & y) === 0 && l.reactions !== null || ce(l)) && (o = kt(l)), P.set(l, o), o;
    }
  } else n && (l = /** @type {Derived} */
  e, gt(l) && Zt(l));
  if ((e.f & dt) !== 0)
    throw e.v;
  return e.v;
}
function ce(e) {
  if (e.v === g) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (P.has(t) || (t.f & T) !== 0 && ce(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
function rn(e) {
  var t = M;
  try {
    return M = !0, e();
  } finally {
    M = t;
  }
}
const sn = -7169;
function S(e, t) {
  e.f = e.f & sn | t;
}
const on = ["touchstart", "touchmove"];
function ln(e) {
  return on.includes(e);
}
const un = /* @__PURE__ */ new Set(), It = /* @__PURE__ */ new Set();
let Ut = null;
function ft(e) {
  var t = this, n = (
    /** @type {Node} */
    t.ownerDocument
  ), r = e.type, s = e.composedPath?.() || [], i = (
    /** @type {null | Element} */
    s[0] || e.target
  );
  Ut = e;
  var l = 0, a = Ut === e && e.__root;
  if (a) {
    var o = s.indexOf(a);
    if (o !== -1 && (t === document || t === /** @type {any} */
    window)) {
      e.__root = t;
      return;
    }
    var u = s.indexOf(t);
    if (u === -1)
      return;
    o <= u && (l = o);
  }
  if (i = /** @type {Element} */
  s[l] || e.target, i !== t) {
    wt(e, "currentTarget", {
      configurable: !0,
      get() {
        return i || n;
      }
    });
    var c = p, d = _;
    C(null), I(null);
    try {
      for (var h, f = []; i !== null; ) {
        var v = i.assignedSlot || i.parentNode || /** @type {any} */
        i.host || null;
        try {
          var A = i["__" + r];
          if (A != null && (!/** @type {any} */
          i.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          e.target === i))
            if (jt(A)) {
              var [ut, ...at] = A;
              ut.apply(i, [e, ...at]);
            } else
              A.call(i, e);
        } catch (z) {
          h ? f.push(z) : h = z;
        }
        if (e.cancelBubble || v === t || v === null)
          break;
        i = v;
      }
      if (h) {
        for (let z of f)
          queueMicrotask(() => {
            throw z;
          });
        throw h;
      }
    } finally {
      e.__root = t, delete e.currentTarget, C(c), I(d);
    }
  }
}
function an(e, t) {
  return fn(e, t);
}
const H = /* @__PURE__ */ new Map();
function fn(e, { target: t, anchor: n, props: r = {}, events: s, context: i, intro: l = !0 }) {
  Ve();
  var a = /* @__PURE__ */ new Set(), o = (d) => {
    for (var h = 0; h < d.length; h++) {
      var f = d[h];
      if (!a.has(f)) {
        a.add(f);
        var v = ln(f);
        t.addEventListener(f, ft, { passive: v });
        var A = H.get(f);
        A === void 0 ? (document.addEventListener(f, ft, { passive: v }), H.set(f, 1)) : H.set(f, A + 1);
      }
    }
  };
  o(ve(un)), It.add(o);
  var u = void 0, c = We(() => {
    var d = n ?? t.appendChild(Ye());
    return Ue(
      /** @type {TemplateNode} */
      d,
      {
        pending: () => {
        }
      },
      (h) => {
        if (i) {
          Oe({});
          var f = (
            /** @type {ComponentContext} */
            L
          );
          f.c = i;
        }
        s && (r.$$events = s), u = e(h, r) || {}, i && Re();
      }
    ), () => {
      for (var h of a) {
        t.removeEventListener(h, ft);
        var f = (
          /** @type {number} */
          H.get(h)
        );
        --f === 0 ? (document.removeEventListener(h, ft), H.delete(h)) : H.set(h, f);
      }
      It.delete(o), d !== n && d.parentNode?.removeChild(d);
    };
  });
  return At.set(u, c), u;
}
let At = /* @__PURE__ */ new WeakMap();
function cn(e, t) {
  const n = At.get(e);
  return n ? (At.delete(e), n(t)) : Promise.resolve();
}
class hn {
  /**
   * Create a new lifecycle manager
   * @param {ArizonaSvelteRegistry} registry - Component registry instance
   * @param {Object} [options={}] - Lifecycle options
   * @param {boolean} [options.autoMount=true] - Automatically mount new components
   * @param {boolean} [options.autoUnmount=true] - Automatically unmount removed components
   * @param {boolean} [options.observeSubtree=true] - Monitor entire DOM tree
   * @param {number} [options.debounceMs=0] - Debounce delay in milliseconds
   * @throws {Error} If registry is not provided
   */
  constructor(t, n = {}) {
    if (!t)
      throw new Error("ArizonaSvelteLifecycle requires a registry instance");
    this.registry = t, this.mountedComponents = /* @__PURE__ */ new Map(), this.observers = /* @__PURE__ */ new Set(), this.isMonitoring = !1, this.options = {
      autoMount: n.autoMount !== !1,
      // Default true
      autoUnmount: n.autoUnmount !== !1,
      // Default true
      observeSubtree: n.observeSubtree !== !1,
      // Default true
      debounceMs: n.debounceMs || 0,
      // Debounce DOM changes
      ...n
    }, this.debounceTimer = null;
  }
  /**
   * Mount Svelte components from DOM data attributes
   * Searches for elements with data-svelte-component attribute and mounts the corresponding components
   * @returns {Promise<number>} Number of components successfully mounted
   * @example
   * // HTML: <div data-svelte-component="Counter" data-svelte-props='{"count": 0}'></div>
   * const mounted = await lifecycle.mountComponents();
   */
  async mountComponents() {
    const t = document.querySelectorAll("[data-svelte-component]");
    let n = 0;
    return t.forEach((r) => {
      if (this.mountedComponents.has(r))
        return;
      const s = r.dataset.svelteComponent, i = r.dataset.svelteProps ? JSON.parse(r.dataset.svelteProps) : {}, l = this.registry.getComponent(s);
      if (l)
        try {
          const a = an(l, { target: r, props: i });
          this.mountedComponents.set(r, a), n++, console.log(`[Arizona Svelte] ✅ Mounted '${s}' component`, {
            target: r.id || r.className || "unnamed",
            props: i,
            totalMounted: this.mountedComponents.size
          });
        } catch (a) {
          console.error(`[Arizona Svelte] ❌ Failed to mount component '${s}':`, a);
        }
      else
        console.warn(`[Arizona Svelte] Component '${s}' not found in registry`);
    }), n > 0 && console.log(`[Arizona Svelte] Mounted ${n} components`), n;
  }
  /**
   * Unmount a specific component
   * @param {Element} target - DOM element containing the component
   * @returns {boolean} True if component was unmounted, false if not found
   */
  unmountComponent(t) {
    const n = this.mountedComponents.get(t);
    if (n)
      try {
        const r = t.dataset.svelteComponent || "unknown";
        return cn(n), this.mountedComponents.delete(t), console.log(`[Arizona Svelte] 🗑️ Unmounted '${r}' component`, {
          target: t.id || t.className || "unnamed",
          totalMounted: this.mountedComponents.size
        }), !0;
      } catch (r) {
        return console.error("[Arizona Svelte] ❌ Failed to unmount component:", r), !1;
      }
    return !1;
  }
  /**
   * Unmount all mounted components
   * @returns {number} Number of components unmounted
   */
  unmountAllComponents() {
    let t = 0;
    return this.mountedComponents.forEach((n, r) => {
      this.unmountComponent(r) && t++;
    }), console.log(`[Arizona Svelte] Unmounted ${t} components`), t;
  }
  /**
   * Remount components (useful for updates)
   * @returns {Promise<number>} Number of components remounted
   */
  async remountComponents() {
    return this.unmountAllComponents(), await this.mountComponents();
  }
  /**
   * Get mounted component instance by target
   * @param {Element} target - DOM element
   * @returns {Object|null} Component instance or null if not found
   */
  getMountedComponent(t) {
    return this.mountedComponents.get(t) || null;
  }
  /**
   * Get all mounted components
   * @returns {Map} Map of target elements to component instances
   */
  getAllMountedComponents() {
    return new Map(this.mountedComponents);
  }
  /**
   * Check if a target has a mounted component
   * @param {Element} target - DOM element
   * @returns {boolean}
   */
  isComponentMounted(t) {
    return this.mountedComponents.has(t);
  }
  /**
   * Start automatic monitoring for component lifecycle
   * @returns {void}
   */
  startMonitoring() {
    if (this.isMonitoring) {
      console.warn("[Arizona Svelte] Monitoring already started");
      return;
    }
    this.isMonitoring = !0, console.log("[Arizona Svelte] Starting automatic component monitoring"), this.options.autoMount && this.mountComponents(), this.setupDOMObserver(), this.setupArizonaListener(), this.setupVisibilityListener(), this.setupUnloadListener();
  }
  /**
   * Stop automatic monitoring
   * @returns {void}
   */
  stopMonitoring() {
    this.isMonitoring && (this.isMonitoring = !1, console.log("[Arizona Svelte] Stopping automatic component monitoring"), this.observers.forEach((t) => {
      t.disconnect ? t.disconnect() : typeof t == "function" && t();
    }), this.observers.clear(), this.debounceTimer && (clearTimeout(this.debounceTimer), this.debounceTimer = null));
  }
  /**
   * Setup DOM mutation observer to detect component additions/removals
   * @private
   */
  setupDOMObserver() {
    const t = new MutationObserver((n) => {
      this.debouncedHandleMutations(n);
    });
    t.observe(document.body, {
      childList: !0,
      subtree: this.options.observeSubtree,
      attributes: !0,
      attributeFilter: ["data-svelte-component", "data-svelte-props"]
    }), this.observers.add(t);
  }
  /**
   * Setup Arizona WebSocket event listener for patches
   * @private
   */
  setupArizonaListener() {
    const t = (r) => {
      r.detail.type === "html_patch" && this.debouncedScanAndMount();
    };
    document.addEventListener("arizonaEvent", t);
    const n = () => {
      document.removeEventListener("arizonaEvent", t);
    };
    this.observers.add(n);
  }
  /**
   * Setup page visibility listener to pause/resume components
   * @private
   */
  setupVisibilityListener() {
    const t = () => {
      document.hidden ? console.log("[Arizona Svelte] Page hidden - components may pause updates") : (console.log("[Arizona Svelte] Page visible - checking for component updates"), this.debouncedScanAndMount());
    };
    document.addEventListener("visibilitychange", t);
    const n = () => {
      document.removeEventListener("visibilitychange", t);
    };
    this.observers.add(n);
  }
  /**
   * Setup page unload listener for cleanup
   * @private
   */
  setupUnloadListener() {
    const t = () => {
      console.log("[Arizona Svelte] Page unloading - cleaning up components"), this.options.autoUnmount && this.unmountAllComponents(), this.stopMonitoring();
    };
    window.addEventListener("beforeunload", t), window.addEventListener("unload", t);
    const n = () => {
      window.removeEventListener("beforeunload", t), window.removeEventListener("unload", t);
    };
    this.observers.add(n);
  }
  /**
   * Debounced mutation handler to avoid excessive re-scanning
   * @private
   */
  debouncedHandleMutations(t) {
    this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(() => {
      this.handleMutations(t);
    }, this.options.debounceMs);
  }
  /**
   * Debounced scan and mount to avoid excessive operations
   * @private
   */
  debouncedScanAndMount() {
    this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(() => {
      this.scanAndMount();
    }, this.options.debounceMs);
  }
  /**
   * Handle DOM mutations and update components accordingly
   * @private
   */
  handleMutations(t) {
    let n = !1;
    const r = /* @__PURE__ */ new Set();
    t.forEach((s) => {
      s.type === "childList" && s.removedNodes.length > 0 && s.removedNodes.forEach((i) => {
        i.nodeType === Node.ELEMENT_NODE && (r.add(i), this.unmountRemovedComponents(i));
      }), (s.type === "childList" && s.addedNodes.length > 0 || s.type === "attributes" && (s.attributeName === "data-svelte-component" || s.attributeName === "data-svelte-props")) && (n = !0);
    }), n && this.options.autoMount && this.scanAndMount();
  }
  /**
   * Scan for new components and mount them
   * @private
   */
  async scanAndMount() {
    try {
      const t = await this.mountComponents();
      t > 0 && console.log(`[Arizona Svelte] 🔄 Auto-mounted ${t} new components`);
    } catch (t) {
      console.error("[Arizona Svelte] Error during auto-mount:", t);
    }
  }
  /**
   * Unmount components that were removed from DOM
   * @private
   */
  unmountRemovedComponents(t) {
    this.options.autoUnmount && (this.mountedComponents.has(t) && (console.log("[Arizona Svelte] Auto-unmounting removed component"), this.unmountComponent(t)), t.querySelectorAll && t.querySelectorAll("[data-svelte-component]").forEach((r) => {
      this.mountedComponents.has(r) && (console.log("[Arizona Svelte] Auto-unmounting removed child component"), this.unmountComponent(r));
    }));
  }
  /**
   * Get monitoring status
   * @returns {boolean}
   */
  isMonitoringActive() {
    return this.isMonitoring;
  }
  /**
   * Get current monitoring options
   * @returns {Object}
   */
  getMonitoringOptions() {
    return { ...this.options };
  }
  /**
   * Update monitoring options
   * @param {Object} newOptions - New options to merge
   */
  updateMonitoringOptions(t) {
    this.options = { ...this.options, ...t };
  }
}
class vn {
  /**
   * Create a new ArizonaSvelte instance
   * @param {Object} [options={}] - Configuration options
   * @param {Object.<string, Function>} [options.components] - Components to register on instantiation
   */
  constructor(t = {}) {
    this.registry = new he(), this.lifecycle = new hn(this.registry, t), t.components && this.registerComponents(t.components);
  }
  /**
   * Get a component by name
   * @param {string} name - Component name
   * @returns {Function|null} Svelte component class or null if not found
   */
  getComponent(t) {
    return this.registry.getComponent(t);
  }
  /**
   * Check if a component is registered
   * @param {string} name - Component name
   * @returns {boolean}
   */
  hasComponent(t) {
    return this.registry.hasComponent(t);
  }
  /**
   * Get all registered component names
   * @returns {string[]}
   */
  getComponentNames() {
    return this.registry.getComponentNames();
  }
  /**
   * Get the registry instance
   * @returns {ArizonaSvelteRegistry}
   */
  getRegistry() {
    return this.registry;
  }
  /**
   * Get the lifecycle instance
   * @returns {ArizonaSvelteLifecycle}
   */
  getLifecycle() {
    return this.lifecycle;
  }
  /**
   * Mount Svelte components from DOM
   * @returns {Promise<number>} Number of components mounted
   */
  async mountComponents() {
    return await this.lifecycle.mountComponents();
  }
  /**
   * Start automatic monitoring for component lifecycle
   * This will automatically mount/unmount components when DOM changes
   * @param {Object} [options={}] - Monitoring options
   * @param {boolean} [options.autoMount=true] - Automatically mount new components
   * @param {boolean} [options.autoUnmount=true] - Automatically unmount removed components
   * @param {boolean} [options.observeSubtree=true] - Monitor entire DOM tree
   * @param {number} [options.debounceMs=0] - Debounce delay in milliseconds
   * @returns {Promise<void>}
   * @example
   * arizonaSvelte.startMonitoring({
   *   autoMount: true,
   *   autoUnmount: true,
   *   debounceMs: 0
   * });
   */
  async startMonitoring(t = {}) {
    this.lifecycle.updateMonitoringOptions(t), this.lifecycle.startMonitoring();
  }
  /**
   * Stop automatic monitoring
   * @returns {void}
   */
  stopMonitoring() {
    this.lifecycle.stopMonitoring();
  }
  /**
   * Check if monitoring is active
   * @returns {boolean}
   */
  isMonitoring() {
    return this.lifecycle.isMonitoringActive();
  }
  /**
   * Register multiple components at once
   * @param {Object.<string, Function>} components - Object mapping component names to component classes
   * @returns {number} Number of components registered
   * @example
   * arizonaSvelte.registerComponents({
   *   Counter: CounterComponent,
   *   HelloWorld: HelloWorldComponent,
   *   Dashboard: DashboardComponent
   * });
   */
  registerComponents(t) {
    return this.registry.registerComponents(t);
  }
}
export {
  vn as default
};
//# sourceMappingURL=arizona-svelte.min.js.map
